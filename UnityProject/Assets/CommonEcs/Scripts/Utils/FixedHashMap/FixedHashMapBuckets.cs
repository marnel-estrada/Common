////////////////////////////////////////////////////////////////////////////////
// Warning: This file was automatically generated by SmallBufferGenerator.
//          If you edit this by hand, the next run of SmallBufferGenerator
//          will overwrite your edits.
////////////////////////////////////////////////////////////////////////////////

using System;
using System.Runtime.InteropServices;

using Common;

using Unity.Burst;
using Unity.Collections;

namespace CommonEcs {
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct FixedHashMapBuckets<K, V>
        where K : unmanaged, IEquatable<K>
        where V : unmanaged {
        public ref struct Enumerator {
            private readonly FixedList512<FixedHashMapEntry<K, V>>* m_Elements;

            private int m_Index;

            public Enumerator(FixedList512<FixedHashMapEntry<K, V>>* elements) {
                this.m_Elements = elements;
                this.m_Index = -1;
            }

            public bool MoveNext() {
                this.m_Index++;

                return this.m_Index < 16;
            }

            public ref FixedList512<FixedHashMapEntry<K, V>> Current {
                get {
                    RequireIndexInBounds();

                    return ref this.m_Elements[this.m_Index];
                }
            }

            [BurstDiscard]
            public void RequireIndexInBounds() {
                if (this.m_Index < 0 || this.m_Index >= 16) {
                    throw new InvalidOperationException("Index out of bounds: " + this.m_Index);
                }
            }
        }

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element0;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element1;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element2;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element3;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element4;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element5;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element6;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element7;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element8;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element9;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element10;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element11;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element12;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element13;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element14;

        private readonly FixedList512<FixedHashMapEntry<K, V>> m_Element15;

        public ref FixedList512<FixedHashMapEntry<K, V>> this[int index] {
            get {
                RequireIndexInBounds(index);

                return ref GetElement(index);
            }
        }

        private ref FixedList512<FixedHashMapEntry<K, V>> GetElement(int index) {
            fixed (FixedList512<FixedHashMapEntry<K, V>>* elements = &this.m_Element0) {
                return ref elements[index];
            }
        }

        private void SetElement(int index, FixedList512<FixedHashMapEntry<K, V>> value) {
            fixed (FixedList512<FixedHashMapEntry<K, V>>* elements = &this.m_Element0) {
                elements[index] = value;
            }
        }

        public const int Length = 16;

        public Enumerator GetEnumerator() {
            // Safe because Enumerator is a 'ref struct'
            fixed (FixedList512<FixedHashMapEntry<K, V>>* elements = &this.m_Element0) {
                return new Enumerator(elements);
            }
        }

        [BurstDiscard]
        public void RequireIndexInBounds(int index) {
            if (index < 0 || index >= 16) {
                throw new InvalidOperationException("Index out of bounds: " + index);
            }
        }
    }
}