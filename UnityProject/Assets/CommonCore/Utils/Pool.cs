//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace Common {
	/**
	 * A generic pool class.
	 */
	public class Pool<T> where T : class, new() {
		// We used queue instead of stack so that there's less chance that a recycled instance would
		// be used in more than one context
		private readonly Queue<T> queue = new Queue<T>(10);
		
		// We used HashSet for faster checking if the instance is already in the pool
		private readonly HashSet<T> hashSet = new HashSet<T>();
		
		private static readonly object SYNC_LOCK = new object();

		/**
		 * Requests for an instance
		 */
		public T Request() {
			lock (SYNC_LOCK) {
				// check from pooledList
				if (this.queue.Count <= 0) {
					// create a new one
					return new T();
				}

				// get from pool
				// get from end of the list
				T instance = this.queue.Dequeue();
				this.hashSet.Remove(instance); // Remove from hashSet as well

				return instance;
			}
		}
		

		/**
		 * Returns the instance to the pool
		 */
		public void Recycle(T instance) {
			lock (SYNC_LOCK) {
				Assertion.NotNull(instance);

				// The item to be recycled should not be present in recycled items
				bool alreadyPooled = this.hashSet.Contains(instance);
				Assertion.IsTrue(!alreadyPooled); // Should not be in the recycled items

				if (alreadyPooled) {
					// Don't add if it was already recycled before
					// Note that execution just continues in production
					return;
				}

				this.queue.Enqueue(instance);
				this.hashSet.Add(instance);
			}
		}

        /// <summary>
        /// Returns the current number of recycled instances
        /// </summary>
        public int Count {
            get {
                return this.queue.Count;
            }
        }
	}
}