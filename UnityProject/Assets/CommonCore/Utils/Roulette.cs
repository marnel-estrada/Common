//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

using UnityEngine;

namespace Common {
	/**
	 * A utility class for carrying out a weighted random selection
	 */
	public class Roulette<T> {
		private List<RouletteEntry<T>> entries;

		private float currentStartingInterval;

		/**
		 * Constructor
		 */
		public Roulette() {
			this.entries = new List<RouletteEntry<T>>();
		}

		/**
		 * Clears the roulette selection
		 */
		public void Clear() {
			this.entries.Clear();
			this.currentStartingInterval = 0;
		}

		/**
		 * Adds an item to the roulette
		 */
		public void Add(T item, float probability) {
            Assertion.IsTrue(probability > 0); // probability can't be zero or less than zero

			RouletteEntry<T> entry = new RouletteEntry<T>(item, this.currentStartingInterval, currentStartingInterval + probability);
			this.entries.Add(entry);

			currentStartingInterval += probability;
			Assertion.IsTrue(Comparison.TolerantLesserThanOrEquals(currentStartingInterval, 1.0f)); // Can't exceed 1. If it does then there's something wrong with the whole population in the roulette
		}

		/**
		 * Selects an item in the roulette at random
		 * Probability of each item affects how is it selected
		 */
		public T SelectRandom() {
			// clamp the last entry to 1
			// we set the last chromosome to 1 so we have a tight fit when we are selecting items later
			// there are time when the generated random exceeds that of the last roulette interval
			RouletteEntry<T> last = this.entries[this.entries.Count - 1];
			last.SetRoulette(last.RouletteFrom, 1.0f);
			this.entries[this.entries.Count - 1] = last; // Note that we set it here again because it's a struct

			float random = UnityEngine.Random.value; // a number between 0 and 1

            // Use binary search to search which entry where the ball would fall to
            int minIndex = 0;
            int maxIndex = this.entries.Count - 1;
            int iterationCount = 0; // used for getting out of stack overflow

            while(iterationCount <= this.entries.Count) {
                if(minIndex == maxIndex) {
                    // This means that there's no more items in between them
                    // So return the item
                    return this.entries[minIndex].Item;
                }

                int midIndex = (minIndex + maxIndex) / 2;
                RouletteEntry<T> entry = this.entries[midIndex];

                if (entry.IsWithinRoulette(random)) {
                    // item found
                    return entry.Item;
                } else {
                    if(random < entry.RouletteFrom) {
                        // this means that item is to the left of the mid entry
                        maxIndex = midIndex - 1;
                    } else if(Comparison.TolerantLesserThanOrEquals(entry.RouletteTo, random)) {
                        // this means that the item is to the right of the mid entry
                        minIndex = midIndex + 1;
                    }
                }

                ++iterationCount;
            }

			Assertion.IsTrue(false, "Unable to select an item. Something is definitely wrong: " + random);
			return default(T);
		}
	}
}
