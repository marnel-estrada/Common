////////////////////////////////////////////////////////////////////////////////
// Warning: This file was automatically generated by SmallBufferGenerator.
//          If you edit this by hand, the next run of SmallBufferGenerator
//          will overwrite your edits.
////////////////////////////////////////////////////////////////////////////////

namespace CommonEcs {
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public unsafe struct UShortList16 {
        public ref struct Enumerator {
            private readonly ushort* m_Elements;

            private int m_Index;

            private readonly int m_OriginalVersion;

            private readonly int* m_Version;

            private readonly int m_Length;

            public Enumerator(ushort* elements, int* version, int length) {
                m_Elements = elements;
                m_Index = -1;
                m_OriginalVersion = *version;
                m_Version = version;
                m_Length = length;
            }

            public bool MoveNext() {
                RequireVersionMatch();
                m_Index++;

                return m_Index < m_Length;
            }

            public ref ushort Current {
                get {
                    RequireVersionMatch();
                    RequireIndexInBounds();

                    return ref m_Elements[m_Index];
                }
            }

            [Unity.Burst.BurstDiscard]
            public void RequireVersionMatch() {
                if (m_OriginalVersion != *m_Version) {
                    throw new System.InvalidOperationException("Buffer modified during enumeration");
                }
            }

            [Unity.Burst.BurstDiscard]
            public void RequireIndexInBounds() {
                if (m_Index < 0 || m_Index >= m_Length) {
                    throw new System.InvalidOperationException("Index out of bounds: " + m_Index);
                }
            }
        }

        private readonly ushort m_Element0;

        private readonly ushort m_Element1;

        private readonly ushort m_Element2;

        private readonly ushort m_Element3;

        private readonly ushort m_Element4;

        private readonly ushort m_Element5;

        private readonly ushort m_Element6;

        private readonly ushort m_Element7;

        private readonly ushort m_Element8;

        private readonly ushort m_Element9;

        private readonly ushort m_Element10;

        private readonly ushort m_Element11;

        private readonly ushort m_Element12;

        private readonly ushort m_Element13;

        private readonly ushort m_Element14;

        private readonly ushort m_Element15;

        private int m_Version;

        private int m_Length;

        public ref ushort this[int index] {
            get {
                RequireIndexInBounds(index);

                return ref GetElement(index);
            }
        }

        private ref ushort GetElement(int index) {
            fixed (ushort* elements = &m_Element0) {
                return ref elements[index];
            }
        }

        private void SetElement(int index, ushort value) {
            fixed (ushort* elements = &m_Element0) {
                elements[index] = value;
            }
        }

        public int Count {
            get {
                return m_Length;
            }
        }

        public const int Capacity = 16;

        public Enumerator GetEnumerator() {
            // Safe because Enumerator is a 'ref struct'
            fixed (ushort* elements = &m_Element0) {
                fixed (int* version = &m_Version) {
                    return new Enumerator(elements, version, m_Length);
                }
            }
        }

        public void Add(ushort item) {
            RequireNotFull();
            SetElement(m_Length, item);
            m_Length++;
            m_Version++;
        }

        public void Clear() {
            for (int i = 0; i < m_Length; ++i) {
                SetElement(i, default(ushort));
            }

            m_Length = 0;
            m_Version++;
        }

        public void Insert(int index, ushort value) {
            RequireNotFull();
            RequireIndexInBounds(index);
            for (int i = m_Length; i > index; --i) {
                SetElement(i, GetElement(i - 1));
            }

            SetElement(index, value);
            m_Length++;
            m_Version++;
        }

        public void RemoveAt(int index) {
            RequireIndexInBounds(index);
            for (int i = index; i < m_Length - 1; ++i) {
                SetElement(i, GetElement(i + 1));
            }

            m_Length--;
            m_Version++;
        }

        public void RemoveRange(int index, int count) {
            RequireIndexInBounds(index);
            if (count < 0) {
                throw new System.ArgumentOutOfRangeException("count", "Count must be positive: " + count);
            }

            RequireIndexInBounds(index + count - 1);
            int indexAfter = index + count;
            int indexEndCopy = indexAfter + count;
            if (indexEndCopy >= m_Length) {
                indexEndCopy = m_Length;
            }

            int numCopies = indexEndCopy - indexAfter;
            for (int i = 0; i < numCopies; ++i) {
                SetElement(index + i, GetElement(index + count + i));
            }

            for (int i = indexAfter; i < m_Length - 1; ++i) {
                SetElement(i, GetElement(i + 1));
            }

            m_Length -= count;
            m_Version++;
        }

        [Unity.Burst.BurstDiscard]
        public void RequireNotFull() {
            if (m_Length == 16) {
                throw new System.InvalidOperationException("Buffer overflow");
            }
        }

        [Unity.Burst.BurstDiscard]
        public void RequireIndexInBounds(int index) {
            if (index < 0 || index >= m_Length) {
                throw new System.InvalidOperationException("Index out of bounds: " + index);
            }
        }
    }
}